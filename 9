WATER JUG PROBLEM 

:- dynamic rstate/2. 
start :- 
retractall(rstate(_, _)),  
assert(rstate(0, 0)), 
writeln("Starting from (0, 0)"), 
state(0, 0). 
state(2, 0) :- 
\+ rstate(2, 0), 
assert(rstate(2, 0)), 
writeln("\nGoal reached: (2, 0)"), !. 
state(X, Y) :- 
X < 4, 
\+ rstate(4, Y), 
assert(rstate(4, Y)), 
format('Rule 1 => (4, ~w)~n', [Y]), 
state(4, Y). 
state(X, Y) :- 
Y < 3, 
\+ rstate(X, 3), 
assert(rstate(X, 3)), 
format('Rule 2 => (~w, 3)~n', [X]), 
state(X, 3). 
state(X, Y) :- 
X > 0, 
\+ rstate(0, Y), 
assert(rstate(0, Y)), 
format('Rule 3 => (0, ~w)~n', [Y]), 
state(0, Y). 
state(X, Y) :- 
Y > 0, 
\+ rstate(X, 0), 
assert(rstate(X, 0)), 
format('Rule 4 => (~w, 0)~n', [X]), 
state(X, 0). 
state(X, Y) :- 
X + Y >= 4, 
Y > 0, 
Z is Y - (4 - X), 
\+ rstate(4, Z), 
assert(rstate(4, Z)), 
format('Rule 5 => (4, ~w)~n', [Z]), 
state(4, Z). 
state(X, Y) :- 
X + Y >= 3, 
X > 0, 
Z is X - (3 - Y), 
\+ rstate(Z, 3), 
assert(rstate(Z, 3)), 
format('Rule 6 => (~w, 3)~n', [Z]), 
state(Z, 3). 
state(X, Y) :- 
X + Y =< 4, 
Y > 0, 
Z is X + Y, 
\+ rstate(Z, 0), 
assert(rstate(Z, 0)), 
format('Rule 7 => (~w, 0)~n', [Z]), 
state(Z, 0). 
state(X, Y) :- 
X + Y =< 3, 
X > 0, 
Z is X + Y, 
\+ rstate(0, Z), 
assert(rstate(0, Z)), 
format('Rule 8 => (0, ~w)~n', [Z]), 
state(0, Z). 
% Base case to prevent infinite recursion 
state(_, _) :- !. 




Output:
?- start.
Starting from (0, 0)
Rule 1 => (4, 0)
Rule 2 => (4, 3)
Rule 3 => (0, 3)
Rule 7 => (3, 0)
Rule 2 => (3, 3)
Rule 5 => (4, 2)
Rule 3 => (0, 2)
Rule 7 => (2, 0)
Rule 2 => (2, 3)
Rule 5 => (4, 1)
Rule 3 => (0, 1)
Rule 7 => (1, 0)
Rule 2 => (1, 3)










